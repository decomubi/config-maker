Got it. If your function file is `functions/games.js`, Netlify will expose it as:

```text
/.netlify/functions/games
```

So we only need to point the frontend to **`/games` instead of `/game`**.

Here is the same full `index.html` as before, but with `API_GAME` corrected:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Casino Config Studio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Babel -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind config BEFORE CDN script -->
  <script>
    window.tailwind = {
      config: {
        theme: {
          extend: {
            colors: {
              slate: {
                850: "#151f32",
                900: "#020617"
              }
            }
          }
        }
      }
    };
  </script>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Fonts -->
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
    rel="stylesheet"
  />

  <style>
    body { font-family: "Inter", system-ui, sans-serif; }
    ::-webkit-scrollbar{width:8px;height:8px}
    ::-webkit-scrollbar-track{background:#1e293b}
    ::-webkit-scrollbar-thumb{background:#475569;border-radius:4px}
    ::-webkit-scrollbar-thumb:hover{background:#64748b}
  </style>
</head>
<body class="bg-slate-900 text-slate-100 h-screen overflow-hidden">
  <div id="root" class="h-full"></div>

  <script type="text/babel" data-presets="env,react">
    const { useState, useEffect } = React;

    // === CONFIG ===
    const CLOUD_NAME = 'dqhsuzpv0';
    const UPLOAD_PRESET = 'casino_game_assets';

    // Your backend file is games.js, so use /games here:
    const API_GAME = '/.netlify/functions/games';
    const API_ASSETS = '/.netlify/functions/assets';
    const API_EXPORT = '/.netlify/functions/export-config';
    const API_BUILD_PACK = '/.netlify/functions/build-pack';

    const Toast = ({ message, type, onClose }) => {
      if (!message) return null;
      const bg = type === 'error' ? 'bg-red-500' : 'bg-emerald-500';
      return (
        <div className={`fixed bottom-5 right-5 ${bg} text-white px-4 py-3 rounded-lg shadow-xl flex items-center gap-2 z-50 text-sm`}>
          <span>{message}</span>
          <button onClick={onClose} className="font-bold px-1">âœ•</button>
        </div>
      );
    };

    const Spinner = () => (
      <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>
    );

    function App() {
      const [games, setGames] = useState([]);
      const [selectedGameId, setSelectedGameId] = useState(null);
      const [isLoadingList, setIsLoadingList] = useState(false);
      const [isSaving, setIsSaving] = useState(false);
      const [isDeleting, setIsDeleting] = useState(false);
      const [notification, setNotification] = useState({ msg: '', type: '' });

      const [formData, setFormData] = useState({
        name: '',
        code: '',
        description: '',
        config: '{}'
      });
      const [configObj, setConfigObj] = useState({});
      const [assets, setAssets] = useState([]);

      // Parameter builder
      const [paramKey, setParamKey] = useState('');
      const [paramValue, setParamValue] = useState('');
      const [paramType, setParamType] = useState('string');

      // Upload
      const [uploadLabel, setUploadLabel] = useState('');
      const [uploadFile, setUploadFile] = useState(null);
      const [isUploading, setIsUploading] = useState(false);

      // Target edits per asset: { [assetId]: { w, h } }
      const [targetEdits, setTargetEdits] = useState({});

      // Pack JSON output
      const [packJson, setPackJson] = useState('');

      useEffect(() => {
        fetchGames();
      }, []);

      const showToast = (msg, type) => {
        setNotification({ msg, type });
        setTimeout(() => setNotification({ msg: '', type: '' }), 3500);
      };

      const fetchGames = async () => {
        setIsLoadingList(true);
        try {
          const res = await fetch(API_GAME);
          if (!res.ok) throw new Error('Failed to fetch games');
          const data = await res.json();
          setGames(Array.isArray(data) ? data : []);
        } catch (err) {
          console.error(err);
          showToast('Failed to load games', 'error');
        } finally {
          setIsLoadingList(false);
        }
      };

      const loadGame = async (id) => {
        setSelectedGameId(id);
        setAssets([]);
        try {
          const res = await fetch(API_GAME + '?id=' + encodeURIComponent(id));
          if (!res.ok) throw new Error('Failed to load game');
          const { game, assets } = await res.json();
          const cfg = game.config || {};
          setConfigObj(cfg);
          setFormData({
            id: game.id,
            name: game.name || '',
            code: game.code || '',
            description: game.description || '',
            config: JSON.stringify(cfg, null, 2)
          });
          setAssets(assets || []);
          const edits = {};
          (assets || []).forEach(a => {
            edits[a.id] = {
              w: a.target_width ? String(a.target_width) : '',
              h: a.target_height ? String(a.target_height) : ''
            };
          });
          setTargetEdits(edits);
          setPackJson('');
        } catch (err) {
          console.error(err);
          showToast('Failed to load game', 'error');
        }
      };

      const startNewGame = () => {
        setSelectedGameId('new');
        setConfigObj({});
        setFormData({
          name: '',
          code: '',
          description: '',
          config: '{}'
        });
        setAssets([]);
        setTargetEdits({});
        setPackJson('');
      };

      const syncConfigPreview = (obj) => {
        setFormData(prev => ({
          ...prev,
          config: JSON.stringify(obj, null, 2)
        }));
      };

      const addParam = () => {
        const key = paramKey.trim();
        if (!key) {
          showToast('Parameter name is required', 'error');
          return;
        }

        let value;
        if (paramType === 'number') {
          if (paramValue === '') {
            showToast('Value is required', 'error');
            return;
          }
          value = Number(paramValue);
          if (Number.isNaN(value)) {
            showToast('Value must be a number', 'error');
            return;
          }
        } else if (paramType === 'boolean') {
          value = paramValue === 'true';
        } else {
          value = paramValue;
        }

        const next = { ...configObj, [key]: value };
        setConfigObj(next);
        syncConfigPreview(next);
        setParamKey('');
        setParamValue('');
      };

      const removeParam = (key) => {
        const next = { ...configObj };
        delete next[key];
        setConfigObj(next);
        syncConfigPreview(next);
      };

      const handleSave = async () => {
        if (!formData.name || !formData.code) {
          showToast('Name and Code are required', 'error');
          return;
        }

        setIsSaving(true);
        try {
          const payload = {
            ...formData,
            id: selectedGameId === 'new' ? null : selectedGameId,
            config: configObj
          };

          const res = await fetch(API_GAME, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (!res.ok) throw new Error(await res.text());
          const saved = await res.json();
          showToast('Game saved', 'success');
          await fetchGames();
          await loadGame(saved.id);
        } catch (err) {
          console.error(err);
          showToast('Save failed: ' + err.message, 'error');
        } finally {
          setIsSaving(false);
        }
      };

      const handleDeleteGame = async (idToDelete) => {
        if (!idToDelete) return;
        if (!window.confirm('Delete this game? This cannot be undone.')) return;

        setIsDeleting(true);
        try {
          const res = await fetch(API_GAME + '?id=' + encodeURIComponent(idToDelete), {
            method: 'DELETE'
          });
          if (!res.ok && res.status !== 204) {
            throw new Error(await res.text());
          }
          showToast('Game deleted', 'success');
          await fetchGames();
          if (selectedGameId === idToDelete) startNewGame();
        } catch (err) {
          console.error(err);
          showToast('Delete failed: ' + err.message, 'error');
        } finally {
          setIsDeleting(false);
        }
      };

      const handleUpload = async () => {
        if (!selectedGameId || selectedGameId === 'new') {
          showToast('Save the game first before uploading assets', 'error');
          return;
        }
        if (!uploadLabel || !uploadFile) {
          showToast('Label and File are required', 'error');
          return;
        }

        setIsUploading(true);
        try {
          const url = `https://api.cloudinary.com/v1_1/${CLOUD_NAME}/image/upload`;
          const fd = new FormData();
          fd.append('file', uploadFile);
          fd.append('upload_preset', UPLOAD_PRESET);

          const cRes = await fetch(url, { method: 'POST', body: fd });
          if (!cRes.ok) throw new Error('Cloudinary upload failed');
          const cData = await res.json();

        } catch (err) {
          console.error(err);
        }
      };
    </script>
</body>
</html>
```
