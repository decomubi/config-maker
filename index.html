<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Casino Config Studio</title>

  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tailwind CSS: config BEFORE CDN script -->
  <script>
    tailwind = {
      config: {
        theme: {
          extend: {
            colors: {
              slate: {
                850: "#151f32",
                900: "#0f172a"
              },
              indigo: {
                550: "#4f46e5"
              }
            }
          }
        }
      }
    };
  </script>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Google Fonts -->
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
    rel="stylesheet"
  />

  <style>
    body {
      font-family: "Inter", sans-serif;
    }
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #1e293b;
    }
    ::-webkit-scrollbar-thumb {
      background: #475569;
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #64748b;
    }
  </style>
</head>
<body class="bg-slate-900 text-slate-100 h-screen overflow-hidden">
  <div id="root" class="h-full"></div>

  <script type="text/babel" data-presets="env,react">
    const { useState, useEffect } = React;

    // === CONFIG ===
    const CLOUD_NAME = 'dqhsuzpv0';             // your Cloudinary cloud name
    const UPLOAD_PRESET = 'casino_game_assets'; // your upload preset

    // NOTE: if your function file is games.js instead of game.js,
    // change '/game' to '/games' here:
    const API_GAME = '/.netlify/functions/game';
    const API_ASSETS = '/.netlify/functions/assets';
    const API_EXPORT = '/.netlify/functions/export-config';

    const Toast = ({ message, type, onClose }) => {
      if (!message) return null;
      const bgClass = type === 'error' ? 'bg-red-500' : 'bg-emerald-500';
      return (
        <div className={`fixed bottom-5 right-5 ${bgClass} text-white px-4 py-3 rounded-lg shadow-xl flex items-center gap-3 z-50`}>
          <span>{message}</span>
          <button
            onClick={onClose}
            className="opacity-70 hover:opacity-100 text-xs font-bold"
          >
            âœ•
          </button>
        </div>
      );
    };

    const Spinner = () => (
      <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
    );

    function App() {
      const [games, setGames] = useState([]);
      const [selectedGameId, setSelectedGameId] = useState(null);
      const [isLoadingList, setIsLoadingList] = useState(false);
      const [isSaving, setIsSaving] = useState(false);
      const [isDeleting, setIsDeleting] = useState(false);
      const [notification, setNotification] = useState({ msg: '', type: '' });

      const [formData, setFormData] = useState({
        name: '',
        code: '',
        description: '',
        config: '{}'
      });

      const [configObj, setConfigObj] = useState({});
      const [assets, setAssets] = useState([]);

      const [paramKey, setParamKey] = useState('');
      const [paramValue, setParamValue] = useState('');
      const [paramType, setParamType] = useState('string');

      const [uploadLabel, setUploadLabel] = useState('');
      const [uploadFile, setUploadFile] = useState(null);
      const [isUploading, setIsUploading] = useState(false);

      useEffect(() => {
        fetchGames();
      }, []);

      const showToast = (msg, type) => {
        setNotification({ msg, type });
        setTimeout(() => setNotification({ msg: '', type: '' }), 4000);
      };

      const fetchGames = async () => {
        setIsLoadingList(true);
        try {
          const res = await fetch(API_GAME);
          if (!res.ok) throw new Error('Failed to fetch games');
          const data = await res.json();
          setGames(Array.isArray(data) ? data : []);
        } catch (e) {
          showToast('Failed to fetch games', 'error');
        } finally {
          setIsLoadingList(false);
        }
      };

      const loadGame = async (id) => {
        setSelectedGameId(id);
        setAssets([]);
        try {
          const res = await fetch(API_GAME + '?id=' + encodeURIComponent(id));
          if (!res.ok) throw new Error('Failed to load game');
          const { game, assets } = await res.json();
          const cfg = game.config || {};
          setConfigObj(cfg);
          setFormData({
            id: game.id,
            name: game.name || '',
            code: game.code || '',
            description: game.description || '',
            config: JSON.stringify(cfg, null, 2)
          });
          setAssets(assets || []);
        } catch (e) {
          showToast('Failed to load game details', 'error');
        }
      };

      const startNewGame = () => {
        setSelectedGameId('new');
        setFormData({
          name: '',
          code: '',
          description: '',
          config: '{}'
        });
        setConfigObj({});
        setAssets([]);
      };

      const syncConfigPreview = (obj) => {
        setFormData((prev) => ({
          ...prev,
          config: JSON.stringify(obj, null, 2)
        }));
      };

      const addParam = () => {
        const key = paramKey.trim();
        if (!key) {
          showToast('Parameter name is required', 'error');
          return;
        }

        let value;
        if (paramType === 'number') {
          if (paramValue === '') {
            showToast('Value is required', 'error');
            return;
          }
          value = Number(paramValue);
          if (Number.isNaN(value)) {
            showToast('Value must be a number', 'error');
            return;
          }
        } else if (paramType === 'boolean') {
          value = paramValue === 'true';
        } else {
          value = paramValue;
        }

        const next = { ...configObj, [key]: value };
        setConfigObj(next);
        syncConfigPreview(next);
        setParamKey('');
        setParamValue('');
      };

      const removeParam = (key) => {
        const next = { ...configObj };
        delete next[key];
        setConfigObj(next);
        syncConfigPreview(next);
      };

      const handleSave = async () => {
        if (!formData.name || !formData.code) {
          showToast('Name and Game Code are required', 'error');
          return;
        }

        setIsSaving(true);
        try {
          const payload = {
            ...formData,
            id: selectedGameId === 'new' ? null : selectedGameId,
            config: configObj
          };

          const res = await fetch(API_GAME, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (!res.ok) throw new Error(await res.text());

          const saved = await res.json();
          showToast('Game saved successfully!', 'success');
          await fetchGames();
          await loadGame(saved.id);
        } catch (e) {
          showToast('Save failed: ' + e.message, 'error');
        } finally {
          setIsSaving(false);
        }
      };

      const handleDeleteGame = async (idToDelete) => {
        if (!idToDelete) return;
        if (!window.confirm('Delete this game? This cannot be undone.')) return;

        setIsDeleting(true);
        try {
          const res = await fetch(
            API_GAME + '?id=' + encodeURIComponent(idToDelete),
            { method: 'DELETE' }
          );
          if (!res.ok && res.status !== 204) {
            throw new Error(await res.text());
          }
          showToast('Game deleted', 'success');
          await fetchGames();
          if (selectedGameId === idToDelete) {
            startNewGame();
          }
        } catch (e) {
          showToast('Delete failed: ' + e.message, 'error');
        } finally {
          setIsDeleting(false);
        }
      };

      const handleUpload = async () => {
        if (!selectedGameId || selectedGameId === 'new') {
          showToast('Save the game first before uploading assets.', 'error');
          return;
        }
        if (!uploadLabel || !uploadFile) {
          showToast('Label and File are required', 'error');
          return;
        }

        setIsUploading(true);
        try {
          const url = `https://api.cloudinary.com/v1_1/${CLOUD_NAME}/image/upload`;
          const fd = new FormData();
          fd.append('file', uploadFile);
          fd.append('upload_preset', UPLOAD_PRESET);

          const cRes = await fetch(url, { method: 'POST', body: fd });
          if (!cRes.ok) throw new Error('Cloudinary upload failed');
          const cData = await cRes.json();

          const dbRes = await fetch(API_ASSETS, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              gameId: selectedGameId,
              label: uploadLabel,
              kind: 'image',
              url: cData.secure_url,
              width: cData.width,
              height: cData.height,
              format: cData.format,
              metadata: {
                public_id: cData.public_id,
                version: cData.version,
                resource_type: cData.resource_type
              }
            })
          });

          if (!dbRes.ok) throw new Error('Database save failed');

          showToast('Asset uploaded!', 'success');
          setUploadLabel('');
          setUploadFile(null);
          const fi = document.getElementById('file-input');
          if (fi) fi.value = '';
          loadGame(selectedGameId);
        } catch (e) {
          showToast(e.message, 'error');
        } finally {
          setIsUploading(false);
        }
      };

      const openExport = () => {
        if (!selectedGameId && !formData.code) return;
        const param = formData.code
          ? 'code=' + encodeURIComponent(formData.code)
          : 'id=' + encodeURIComponent(selectedGameId);
        window.open(`${API_EXPORT}?${param}`, '_blank');
      };

      const activeGameClass = (id) =>
        selectedGameId === id
          ? 'bg-indigo-600 text-white shadow-lg shadow-indigo-500/30'
          : 'text-slate-400 hover:bg-slate-800 hover:text-white';

      return (
        <div className="flex h-screen bg-slate-900 text-slate-200">
          {/* Sidebar */}
          <aside className="w-64 border-r border-s
